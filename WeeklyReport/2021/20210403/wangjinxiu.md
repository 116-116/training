##本周
-完成了
   Bellman-Ford算法
数组Distant[i]记录从源点s到顶点i的路径长度，初始化数组Distant[n]为正无穷, Distant[s]为0；  
以下操作循环执行至多n-1次，n为顶点数： 对于每一条边e(u, v)，如果Distant[u] + w(u, v) < Distant[v]，则另Distant[v] = Distant[u]+w(u, v)。w(u, v)为边e(u,v)的权值； 若上述操作没有对Distant进行更新，说明最短路径已经查找完毕，或者部分点不可达，跳出循环。否则执行下次循环；
为了检测图中是否存在负环路，即权值之和小于0的环路。对于每一条边e(u, v)，如果存在Distant[u] + w(u, v) < Distant[v]的边，则图中存在负环路，即是说改图无法求出单源最短路径。否则数组Distant[n]中记录的就是源点s到各顶点的最短路径长度。
SPFA算法
1.初始时，只有把起点放入队列中。
2.遍历与起点相连的边，如果可以松弛就更新距离dis[],然后判断如果这个点没有在队列中就入队标记。
3.出队队首，取消标记，循环，直至队为空。
4.所有能更新的点都更新完毕，dis[]数组中的距离就是，起点到其他点的最短距离。
-学了
    Bellman-Ford算法和SPFA算法，并用代码打出音乐
-进行了
    每天学一点算法，并且复习王金鹏老师上课讲的，提高自己的基础水平，是自己的基础知识扎实一点。
##下周计划
-学习
    学习师哥要讲的算法，掌握其中的要领。
-复习 
    复习上周讲的算法
##本周感想
    觉得自己学的并不扎实，不要好高骛远，以后我会好好学习算法，掌握要领，理解精髓。




 

 

