### Info
* 英文队名sdibt2333
* 俺们没有中文名字
* 队员1 赖欢
* 队员2 许梓炯
* 队员3 傅钊进

### 比赛地址
> http://acm.sdibt.edu.cn/vjudge/contest/view.action?cid=2115#overview
### 做出来的题目
ＡＢＤＨ
#### A
* 一开始自己确实没看懂这个题干嘛的，一直研究样例，后来查了一下字典，发现了＂进制＂，诶～，猜到了．
* 题意:进制转换题，将输入作为不同进制，分别输出它的8进制，10进制，16进制．
* 思路: 按照每种进制分别进行转换．
#### B
* 这也是一个非常神奇的题，这个题是我们队最后才做的，多亏了队长赖欢一直在坚持搞它．
* 题意:我自己感觉这个题告诉了你几组容易出现混淆的数字和字母，你需要进行替换；替换后你需要对前八位按照题目给的公式进行运算；用最后的得到的数值与第九位数字进行比对，相等就输出他的27进制数．不等于就输出＂Ｉｎｖａｌｉｄ＂．嗯．．．其实挺简单的，但是我自己后来补题的时候，进制转换确实有点掉头发．

#### D
* 说到这个题，也是牛逼了，反正．．．我不会的都牛逼就对了．．有规律呀！而且他都给你了，两个式子，递归．不过说实话，如果这个题是我做的，我用递归是一定会时间超限的，而且很麻烦．许梓炯一下想到用ｍａｐ了，显然我是不会ｍａｐ的，因为这个题牛逼嘛．．．在后来补题的过程中，我自学了一下ｍａｐ，搜索了很多ｍａｐ的视频教学，还有课程，ｅｍｍｍｍ，虽然现在让我真正去写一个不一定能够不出错．但是依旧懂了不少东西，ｍａｐ中进行递归查找要比一般的递归查找节省很多很多时间，这是最牛逼的！另外它的ｋｅｙ和ｖａｌｕｅ配对也是我觉得牛逼的一个地方，要比数组模拟灵活很多．
* 题意：给你说一个序号，让你找到这个序号对应的数值，通过题目给的两个式子进行计算．
* • The label of the root is 1/1.
* • The left child of label p/q is p/(p+q).
* • The right child of label p/q is (p+q)/q.

* 思路：ｍａｐ真的牛逼！！！递归一下子．分左孩子，右孩子，分别进行处理．

#### H
* 这个题是在ｃ题做不出来的时候看得，不过这个题确实简单，想到了简单，想不到有点难，比赛的时候，自己首先想到的事逆序对，推了一下发现不太对，然后自己写了几组数，推了一下，发现按照排好的顺序进行比对，将序列不对的进行计数，最后得到的就是答案呀！
* 题意：一串乱序的数，你只能取一个放到最后，问你最少需要几次．

* 思路：按照排好的顺序进行比对，将序列不对的进行计数，最后得到的就是答案呀！


### 补的题目

#### c
* 让我们来看Ｃ题，这个题．．．．有毒．．．．比赛的时候，我们推这个题推了一个小时多．．．．确实有点浪费时间了，但是！后来我们想到了动态规划！太棒了！！！！最开心的是，我们推不出来动态方程．．．．ｍｍｐ确实，自己现在推还是棘手．．．还是自己太菜了．．．
* 题意：举个栗子吧．．．如：1　3　9，用3的几次方去凑9．我理解的就这么简单，3的0次方，3的1次方，3的2次方．
* 思路：for(int i=0; i<=n; i++)
*            dp[i]=1;
*        maxn=p(m,n);
*        //printf("**%d**\n",maxn);
*        for(int i=1; i<=maxn-1; i++)
*        {
*            long long int s=0;
*            s=(long long int )pow(m,i);
*            //printf("**%lld**\n",s);
*            for(int j=(int)s; j<=n; j++)
*            {
*                dp[j]+=dp[j-(int)s];
*            }
*        }

#### E
* 这是一个恶心的ＤＰ题，对，补题的时候我是死活推不出来，死了算了，后来谭超敏给我讲了一遍，然而我依旧很懵．．．再后来自己按照他讲的一点一点自己写，一晚上终于让我搞明白了．
* 题意：计算P(a,b)的值，在1到a个数中找到前面比后面大的数有b次有多少种。
* eg:P(3, 0) = 1{[123]}
* P(3, 1) = 4{[132], [213], [231], 312]}
* P(3, 2) = 1{[321]}

* 思路:咳咳，我觉得这个思路这样解释是最容易明白的．
	若要求：[4][1]
（1）dp[i-1][j-1]*(i-j)
假设用1　2　3作为样例．那么1　2　3中有四个空可以放4这个数，但是，只有将4放在末尾的时候要求的数值是不增加的．所以[3][0]*(4-1)
（2）dp[i-1][j]*(j+1)
假设1　3　2　作为样例那么将4插进去会有如下几种情况：
	　　　4　　1　　3　　2　　　+1+1

	　　　1　　4　　3　　2　　　+1+1
	　
	　　　1　　3　　4　　2　　　+1

	　　　1　　3　　2　　4　　　+1
所以[3][1]*(1+1)
